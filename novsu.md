# 1. Постановка задачи

## 1.1 Наименование задачи

Создать реализацию кодера и декода по алгоритму Хаффмана на языке C

## 1.2 Описание

Программа выполняет кодирование или декодирование по алгоритму Хаффмана.

## 1.3 Спецификации данных

### Формат файла

| Название        | Размер           | Описание  |
| ------------- |:-------------:| :-----|
| Заголовок      | 4 байта | Фиксированные 4 байта 0x55 0x5C 0x6E 0x41 |
| Размер исходного файла     | 4 байта      |    |
| Дерево Хаффмана | 320 байт      |    См. ниже |
| Поток сжатых данных | Динамический | Поток битов описывающие обход дерева для каждого входного байта |

### Дерево Хаффмана

Дерево Хаффмана кодируется обходом дерева в глубину по следующему алгоритму:
Если узел внутренний узел, то записать бит 0 и вызвать рекурсивно функцию обхода для
левого и правого потомков. Иначе если узел является листом, то записать бит 1 и 
далее 8 битов на соответствующий байт.

Т.к. дерево состоит из 256 листов и 255 внутренних узлов, то суммарный объем в битах равен `256*(1 + 8) + 255*1 = 2559 битов`. 

После обхода дерева записывается контрольный нулевой бит.

### Поток сжатых данных

Потоком данных являются маршруты по дереву. Если записан 0, то идти налево, иначе направо. 

Если входной файл был нулевой длинны, то поток так же будет нулевой длинны.

Последний байт при необходимости будет дополнен нулевыми битами до целого байта.

## 1.4 Внешние спецификации функций программы

Программа должна принять на вход режим работы (кодирование или раскодирование), имя входного файла и имя выходного. В процессе работы программа должна считать входной файл и создать выходной.

## 1.5 Математическая формулировка задачи

- Программа на основе статистики входных данных создает сопоставление байтов в потоки бит вариативной длины, причем ни один из них не является началом другого.

- Описание маршрута по двоичному дереву всегда будет однозначно приводить к конкретному узлу

- Входной файл не должен быть более 100мб из-за особенностей реализации. Это ограничение можно обойти при доработке программы. После возможной доработки входой файл должен быть не более чем 0xFFFFFFFF байт из-за ограничений формата заголовка

## 1.6 Спецификации интерфейса

### Для скомпилированной программы

```bash
# Кодирование
./main encode <input file name> <output file name>

# Декодирование
./main decode <input file name> <output file name>

```

### Для использования в других программах

Файл `./huffman.c` экспортирует 2 функции, `huffman_encode` и `huffman_decode`

```C
/**
 * Кодирование
 * *in - указатель на буфер с входными данными
 * len - длинна входного буфера
 * *outlen - указатель на переменную куда будет записан размер выходного буфера
 * 
 * Функция создаёт буфер размера outlen через malloc и 
 * возвращает его адрес в случае успеха.
 * В случае ошибки возвращает NULL 
 * */
unsigned char *huffman_encode(unsigned char *in, uint32_t len, uint32_t *outlen)

/**
 * Декодирование
 * *in - указатель на буфер с входными данными
 * *outlen - указатель на переменную куда будет записан размер выходного буфера
 * 
 * Функция создает выходной буфер через malloc и возвращает его адрес в случае успеха.
 * В случае ошибки возвращает NULL
 * 
 * Размер буфера с входными данными не указывается потому как он однозначно определяется из заголовка)
 * При этом функция ожидает что входной буфер соответствует формату данных, т.е. он как минимум 4+4+320 байт
 * */
unsigned char *huffman_decode(unsigned char *in, uint32_t *outlen)

```


## 1.7 Внешние данные тестирования

Тестирование выполняется скриптом `./test.sh`. Скрипт тестирование кодирует данные, и затем декодирует.

Так же проверяется корректность кодирования с использованием референсной реализацией на Typescript.

Тестирование выполняется на следующих файлах:
- zero: файл нулевой длинны
- one: файл с одним байтом
- fibonachi10: файл с частотами байтов на 1-е десять членов последовательности Фибоначчи
- fibonachi30: Так же как и fibonachi10, только 30
- hpmor_ru.html: HTML версия книги "Гарри Поттер и методы рационального мышления"

## 1.8 Пример работы

```bash
./main encode myfile.txt myfile.txt.encoded

./main decode myfile.txt.encoded myfile.txt
```

# 2. Проектирование задачи

## 2.1 Наименование программы

"Супер-архиватор"

## 2.2 Уточненное словесное описание задачи

См. 1.2

## 2.3 Выбор метода решения поставленной задачи

Использовалось описание алгоритма Хаффмана с Википедии

## 2.4 Уточненные глобальные данные программы и пользовательские типы

### Структура одной ноды дерева в кодере

`struct HuffmanNode`, структура, используется для создания дерева в кодере.
Является и частью списка и частью дерева

### Структура одной ноды дерева в декодере

`struct HuffmanNodeDecode`, структура, используется в дереве декодера

### Структура потока

`StreamNode`, структура, используется в кодере для создание отображения байтов в поток битов

## 2.5 Декомпозиция функций

```C
/**
 * Записывает бит в структуру StreamNode
 * */
void writeBitToStreamNode(struct StreamNode *node, char bitIdx, char bit)

/**
 * Выполняет обход дерева и создаёт записи в массиве StreamNode
 */
void goTreeForStream(struct HuffmanNode *list, struct StreamNode *bytes, int idx, struct StreamNode *path)

/**
 * Записывает бит в буфере *out и увеличивает позиции *outlen и *currentBit
 * */
void writeBit(unsigned char *out, uint32_t *outlen, unsigned char *currentBit, char bit)

/** 
 * Считывает бит из буфера и увеличивает позиции *outlen и *currentBit
 * */
char readBit(unsigned char *in, uint32_t *currentByte, unsigned char *currentBit)

/**
 * Выполняет обход дерева и записывает результаты обхода в *out
 * */
void writeHeaderNode(struct HuffmanNode *list, unsigned char *out, uint32_t *outlen, unsigned char *currentBit, int idx)

/**
 * Считывает дерево из заголовка входного кодированного файла и создает дерево для декодера
 * */
void readHuffmanTree(
    struct HuffmanNodeDecode *tree,
    short int currentIdx,
    short int *freeIdx,
    unsigned char *in,
    uint32_t *currentByte, unsigned char *currentBit)
```

## 2.6 Алгоритмизация

### Кодер

Выполняется в два прохода. Первым проходом создаётся статистика по используемым байтам в массиве `counts`.

Затем создается массив `list` с 511-ю элементами `HuffmanNode`. Первые 256 элементов массива - это 
листья для каждого байта. Они так же являются связным списком.

Затем выполняются проходы по списку, находится пара с наименьшими частотами, создаётся новая нода в списке `list` начиная с 256-й и до 511-й. Пара удаляется из связного списка, и новая нода добавляется в него.
Цикл продолжается до тех пор пока в связном списке больше одного элемента.

Дерево создано, его корень - это элемент с индексом 510 (511-й) в списке т.к. этот узел был создан последним.

Далее создается массив `bytes` с `StreamNode`, индексы массива являются соответствующими байтами. После заполнения
этого массива И записи заголовка оригинальное дерево больше не нужно и оно освобождается.

Далее, для каждого байта входного буфера (второй проход по исходным данным) находится соответствущий элемент в `bytes` и записываются его биты.


# 3. Кодирование

Исходный текст программы доступен в этом репозитории

# 4. Демонстрация

Функции кодирования и декодирования были собраны в WebAssembly. Демо доступно по адресу <https://roginvs.github.io/huffman_coding/web/>


# 5. Выводы

Программа выполняет сжатие без потерь, но хуже чем более совершенные алгоритмы.

На тестовом текстовом файле с оригинальным размеров 8мб сжатая версия
получилась около 4мб. Тот же файл при сжатии через 7z получится в районе 1.5мб.

# 1. Постановка задачи

## 1.1 Наименование задачи

Создать реализацию кодера и декода по алгоритму Хаффмана на языке C

## 1.2 Описание

Программа выполняет кодирование или декодирование по алгоритму Хаффмана.

## 1.3 Спецификации данных

### Формат файла

| Название        | Размер           | Описание  |
| ------------- |:-------------:| :-----|
| Заголовок      | 4 байта | Фиксированные 4 байта 0x55 0x5C 0x6E 0x41 |
| Размер исходного файла     | 4 байта      |    |
| Дерево Хаффмана | 320 байт      |    См. ниже |
| Поток сжатых данных | Динамический | Поток битов описывающие обход дерева для каждого входного байта |

### Дерево Хаффмана

Дерево Хаффмана кодируется обходом дерева в глубину по следующему алгоритму:
Если узел внутренний узел, то записать бит 0 и вызвать рекурсивно функцию обхода для
левого и правого потомков. Иначе если узел является листом, то записать бит 1 и 
далее 8 битов на соответствующий байт.

Т.к. дерево состоит из 256 листов и 255 внутренних узлов, то суммарный объем в битах равен `256*(1 + 8) + 255*1 = 2559 битов`. 

После обхода дерева записывается контрольный нулевой бит.

### Поток сжатых данных

Потоком данных являются маршруты по дереву. Если записан 0, то идти налево, иначе направо. 

Если входной файл был нулевой длинны, то поток так же будет нулевой длинны.

Последний байт при необходимости будет дополнен нулевыми битами до целого байта.

## 1.4 Внешние спецификации функций программы

Программа должна принять на вход режим работы (кодирование или раскодирование), имя входного файла и имя выходного. В процессе работы программа должна считать входной файл и создать выходной.

## 1.5 Математическая формулировка задачи

- Программа на основе статистики входных данных создает сопоставление байтов в потоки бит вариативной длины, причем ни один из них не является началом другого.

- Описание маршрута по двоичному дереву всегда будет однозначно приводить к конкретному узлу

- Входной файл не должен быть более 100мб из-за особенностей реализации. Это ограничение можно обойти при доработке программы. После возможной доработки входой файл должен быть не более чем 0xFFFFFFFF байт из-за ограничений формата заголовка

## 1.6 Спецификации интерфейса

### Для скомпилированной программы

```bash
# Кодирование
./main encode <input file name> <output file name>

# Декодирование
./main decode <input file name> <output file name>

```

### Для использования в других программах

Файл `./huffman.c` экспортирует 2 функции, `huffman_encode` и `huffman_decode`

```C
/**
 * Кодирование
 * *in - указатель на буфер с входными данными
 * len - длинна входного буфера
 * *outlen - указатель на переменную куда будет записан размер выходного буфера
 * 
 * Функция создаёт буфер размера outlen через malloc и 
 * возвращает его адрес в случае успеха.
 * В случае ошибки возвращает NULL 
 * */
unsigned char *huffman_encode(unsigned char *in, uint32_t len, uint32_t *outlen)

/**
 * Декодирование
 * *in - указатель на буфер с входными данными
 * *outlen - указатель на переменную куда будет записан размер выходного буфера
 * 
 * Функция создает выходной буфер через malloc и возвращает его адрес в случае успеха.
 * В случае ошибки возвращает NULL
 * 
 * Размер буфера с входными данными не указывается потому как он однозначно определяется из заголовка)
 * При этом функция ожидает что входной буфер соответствует формату данных, т.е. он как минимум 4+4+320 байт
 * */
unsigned char *huffman_decode(unsigned char *in, uint32_t *outlen)

```


## 1.7 
